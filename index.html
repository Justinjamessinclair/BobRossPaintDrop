<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bob Ross Paint Drop</title>
  <style>
    body, html { margin:0; padding:0; background:#fdfdfd; height:100%; overflow:hidden; font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; }
    .hidden { display:none!important; }
    #mainScreen { position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.5); z-index:10; display:flex; justify-content:center; align-items:center; }
    #mainScreen .start-content { background:rgba(255,255,255,0.85); border-radius:24px; box-shadow:0 8px 32px rgba(0,0,0,0.10), 0 1.5px 6px rgba(0,0,0,0.04); padding:40px 32px 32px 32px; display:flex; flex-direction:column; align-items:center; min-width:320px; max-width:90vw; }
    #mainScreen .settings-panel { background:rgba(245,247,250,0.95); border-radius:14px; padding:18px 20px 12px 20px; box-shadow:0 1px 6px #0001; margin-top:18px; width:100%; max-width:340px; display:flex; flex-direction:column; gap:10px; }
    #mainScreen .settings-panel label { display:flex; justify-content:space-between; align-items:center; font-size:1rem; color:#333; margin:6px 0; }
    #mainScreen .settings-panel input[type="range"] { width:90px; }
    #mainScreen .settings-panel input[type="checkbox"] { transform:scale(1.2); margin-left:8px; }
    #feedback { position:fixed; left:50%; top:80px; transform:translateX(-50%) scale(0.8); background:rgba(34,34,34,0.6); color:#fff; font-size:1rem; padding:6px 16px; border-radius:12px; box-shadow:0 2px 8px #0002; z-index:20; pointer-events:none; opacity:0; transition:opacity 0.4s, transform 0.2s; }
    #feedback:not(.hidden) { opacity:1; }
    #hud { position:fixed; top:0; left:50%; transform:translateX(-50%); width:90%; max-width:600px; height:60px; background:rgba(255,255,255,0.95); display:flex; justify-content:center; align-items:center; gap:8px; padding:0 10px; box-sizing:border-box; border-bottom:1px solid #ccc; border-radius:0 0 10px 10px; z-index:4; }
    #hud div { font-size:14px; color:#222; display:flex; align-items:center; gap:4px; }
    button { padding:6px 10px; background:#333; color:white; border:none; border-radius:10px; cursor:pointer; z-index:4; }
    #settingsPanel { position:fixed; top:70px; right:5%; width:200px; background:rgba(50,50,50,0.95); color:white; font-size:13px; padding:10px; border-radius:12px; z-index:4; display:none; }
    #settingsPanel label { display:flex; justify-content:space-between; margin:4px 0; }
    #settingsPanel .shape-option { margin:6px 0; }
    #gameCanvas { width:90vw; max-width:600px; aspect-ratio:3/4; display:block; margin:70px auto 0; background:linear-gradient(#87CEEB,#fff); border-radius:12px; box-shadow:0 0 10px rgba(0,0,0,0.1); }
    #pauseControls {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      display: none;
      flex-direction: column;
      gap: 16px;
      align-items: center;
      background: rgba(30,30,30,0.92);
      padding: 30px 40px;
      border-radius: 18px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.25);
    }
    #pauseControls button {
      font-size: 20px;
      padding: 12px 28px;
      border-radius: 12px;
      background: #333;
      color: #fff;
      border: none;
      cursor: pointer;
    }
    #startScreen {
      background: linear-gradient(135deg, #f8fafc 0%, #e3e9f1 100%);
      color: #222;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      letter-spacing: 0.01em;
    }
    .start-content {
      background: rgba(255,255,255,0.85);
      border-radius: 24px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.10), 0 1.5px 6px rgba(0,0,0,0.04);
      padding: 40px 32px 32px 32px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 320px;
      max-width: 90vw;
    }
    .main-title {
      font-size: 2.6rem;
      font-weight: 700;
      margin-bottom: 18px;
      letter-spacing: -0.01em;
      color: #222;
      text-shadow: 0 2px 12px #fff8, 0 1px 0 #fff;
    }
    .start-btn {
      font-size: 1.3rem;
      padding: 14px 38px;
      border-radius: 16px;
      background: linear-gradient(90deg, #222 0%, #444 100%);
      color: #fff;
      font-weight: 600;
      border: none;
      margin-bottom: 18px;
      margin-top: 8px;
      box-shadow: 0 2px 8px #0001;
      transition: background 0.2s;
    }
    .start-btn:hover, .start-btn:focus {
      background: linear-gradient(90deg, #444 0%, #222 100%);
      outline: none;
    }
    .pause-hint {
      margin-bottom: 18px;
      font-size: 1.1rem;
      color: #888;
      text-shadow: none;
      font-weight: 500;
    }
    .controls-instructions {
      background: rgba(245,247,250,0.95);
      border-radius: 14px;
      padding: 18px 20px 12px 20px;
      box-shadow: 0 1px 6px #0001;
      margin-top: 0;
      width: 100%;
      max-width: 340px;
    }
    .controls-instructions h2 {
      font-size: 1.15rem;
      font-weight: 600;
      margin: 0 0 10px 0;
      margin-top: 1em;
      color: #333;
      letter-spacing: 0.01em;
    }
    .controls-instructions ul {
      list-style: none;
      padding: 0;
      margin: 0 0 10px 0;
    }
    .controls-instructions li {
      margin-bottom: 7px;
      font-size: 1rem;
      color: #333;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .kbd {
      display: inline-block;
      background: #f3f4f6;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      padding: 2px 8px;
      font-size: 0.98em;
      font-family: inherit;
      color: #222;
      margin: 0 2px;
      box-shadow: 0 1px 2px #0001;
    }
    .tip {
      margin-top: 10px;
      font-size: 1rem;
      color: #666;
      text-align: center;
    }
    @media (max-width: 500px) {
      .start-content { padding: 24px 6vw 18px 6vw; }
      .controls-instructions { padding: 12px 6vw 8px 6vw; }
      .main-title { font-size: 2rem; }
    }
    #pauseControls {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      display: none;
      flex-direction: column;
      align-items: center;
      background: linear-gradient(135deg, #f8fafc 0%, #e3e9f1 100%);
      border-radius: 24px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.10), 0 1.5px 6px rgba(0,0,0,0.04);
      padding: 40px 32px 32px 32px;
      min-width: 320px;
      max-width: 90vw;
    }
    .pause-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
    }
    .pause-title {
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 18px;
      color: #222;
      text-shadow: 0 2px 12px #fff8, 0 1px 0 #fff;
    }
    .pause-btn {
      font-size: 1.1rem;
      padding: 12px 38px;
      border-radius: 16px;
      background: linear-gradient(90deg, #222 0%, #444 100%);
      color: #fff;
      font-weight: 600;
      border: none;
      margin-bottom: 12px;
      margin-top: 8px;
      box-shadow: 0 2px 8px #0001;
      transition: background 0.2s;
      width: 100%;
      max-width: 220px;
    }
    .pause-btn:hover, .pause-btn:focus {
      background: linear-gradient(90deg, #444 0%, #222 100%);
      outline: none;
    }
    #pauseControlsInstructions {
      width: 100%;
      margin-bottom: 18px;
    }
    #pauseScreen {
      position: absolute;
      top: 0; left: 0; width: 100vw; height: 100vh;
      display: flex; justify-content: center; align-items: center;
      background: rgba(0,0,0,0.5);
      z-index: 10;
    }
    .settings-panel {
      background: rgba(245,247,250,0.95);
      border-radius: 14px;
      padding: 18px 20px 12px 20px;
      box-shadow: 0 1px 6px #0001;
      margin-top: 18px;
      width: 100%;
      max-width: 340px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .settings-panel label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 1rem;
      color: #333;
      margin: 6px 0;
    }
    .settings-panel input[type="range"] {
      width: 90px;
    }
    .settings-panel input[type="checkbox"] {
      transform: scale(1.2);
      margin-left: 8px;
    }
    @media (max-width: 500px) {
      #pauseScreen .start-content { padding: 24px 6vw 18px 6vw; }
      .settings-panel { padding: 12px 6vw 8px 6vw; }
    }
  </style>
</head>
<body>
  <div id="homeScreen">
    <div class="start-content">
      <h1 class="main-title">üé® Bob Ross Paint Drop</h1>
      <button id="mainActionBtn" class="start-btn">Start Game</button>
      <div id="pauseHint" class="pause-hint"></div>
      <div class="controls-instructions" id="mainControlsInstructions"></div>
      <button id="mainSettingsBtn" class="start-btn" style="margin-top:10px;">‚öôÔ∏è Settings</button>
      <div id="mainSettingsPanel" class="settings-panel hidden">
        <h2 style="margin-top:0;font-size:1.1rem;color:#333;">Settings</h2>
        <label>
          Hard mode (penalty for missing the target color)
          <input type="checkbox" id="mainMissPenalty" />
        </label>
        <label>Music
          <input type="checkbox" id="mainMusicToggle" checked />
        </label>
        <label>Sound FX
          <input type="checkbox" id="mainSfxToggle" checked />
        </label>
      </div>
    </div>
  </div>
  <div id="feedback" class="hidden"></div>
  <div id="overlay" class="hidden"></div>
  <div id="gameOverScreen" class="hidden">
    <div class="start-content" style="text-align:center;">
      <h1 class="main-title" style="margin-bottom:10px;">Game Over</h1>
      <div style="font-size:1.3rem; margin-bottom:12px;">Final Score: <span id="finalScore"></span></div>
      <div style="font-size:1.1rem; margin-bottom:18px;">High Score: <span id="finalHighScore"></span></div>
      <button id="restartBtn" class="start-btn" style="margin-bottom:0;">Restart</button>
    </div>
  </div>
  <div id="hud" class="hidden">
    <div>‚≠ê<span id="score">0</span></div>
    <div>XP:<span id="xp">0</span></div>
    <div>Level:<span id="level">1</span></div>
    <div>‚ù§Ô∏è<span id="lives">3</span></div>
    <div>üéØ<span id="targetColorBox" style="width:20px;height:20px;border-radius:50%;border:1px solid #222;"></span></div>
    <div>üèÜ<span id="highScore">0</span></div>
  </div>
  <div id="pauseControls" class="hidden">
    <div class="pause-content">
      <h2 class="pause-title">‚è∏Ô∏è Paused</h2>
      <div id="pauseControlsInstructions"></div>
      <button id="pauseBtn" class="pause-btn">Resume</button>
      <button id="settingsBtn" class="pause-btn">‚öôÔ∏è Settings</button>
    </div>
  </div>
  <div id="settingsPanel">
    <label>Speed<span><input type="range" id="speedRange" min="5" max="100" value="25" /></span></label>
    <label>Miss Penalty<input type="checkbox" id="missPenalty" /></label>
    <label>Music<input type="checkbox" id="musicToggle" checked /></label>
    <label>Sound FX<input type="checkbox" id="sfxToggle" checked /></label>
  </div>
  <div id="pauseScreen" class="hidden">
    <div class="start-content">
      <h1 class="main-title" id="pauseTitle">üé® Bob Ross Paint Drop</h1>
      <div id="pauseHint" class="pause-hint"></div>
      <div class="controls-instructions" id="pauseControlsInstructions"></div>
      <button id="resumeBtn" class="start-btn">Resume Game</button>
      <button id="openSettingsBtn" class="start-btn">‚öôÔ∏è Settings</button>
      <div id="settingsPanel" class="settings-panel hidden">
        <h2 style="margin-top:0;font-size:1.1rem;color:#333;">Settings</h2>
        <label>Speed<span><input type="range" id="speedRange" min="5" max="100" value="25" /></span></label>
        <label>Miss Penalty<input type="checkbox" id="missPenalty" /></label>
        <label>Music<input type="checkbox" id="musicToggle" checked /></label>
        <label>Sound FX<input type="checkbox" id="sfxToggle" checked /></label>
      </div>
    </div>
  </div>
  <canvas id="gameCanvas" width="600" height="1000"></canvas>
  <div id="trackpad"></div>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const SCALE = 1.5;

      // --- DOM refs ---
      const homeScreen = document.getElementById('homeScreen');
      const mainActionBtn = document.getElementById('mainActionBtn');
      const mainSettingsBtn = document.getElementById('mainSettingsBtn');
      const mainSettingsPanel = document.getElementById('mainSettingsPanel');
      const mainMissPenalty = document.getElementById('mainMissPenalty');
      const mainMusicToggle = document.getElementById('mainMusicToggle');
      const mainSfxToggle = document.getElementById('mainSfxToggle');
      const mainControlsInstructions = document.getElementById('mainControlsInstructions');
      const pauseHint = document.getElementById('pauseHint');
      const hud = document.getElementById('hud');
      const gameOver = document.getElementById('gameOverScreen');
      const finalScoreEl = document.getElementById('finalScore');
      const finalHighScoreEl = document.getElementById('finalHighScore');
      const restartBtn = document.getElementById('restartBtn');
      const scoreEl = document.getElementById('score');
      const xpEl = document.getElementById('xp');
      const levelEl = document.getElementById('level');
      const livesEl = document.getElementById('lives');
      const highScoreEl = document.getElementById('highScore');
      const targetColorBox = document.getElementById('targetColorBox');
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const feedback = document.getElementById('feedback');
      const trackpad = document.getElementById('trackpad');

      // --- State ---
      let savedHighScore = parseInt(localStorage.getItem('highScore')) || 0;
      let savedXP = parseInt(localStorage.getItem('totalXP')) || 0;
      let state = {
        score: 0,
        xpMultiplier: 1,
        lives: 3,
        maxLives: 3,
        xp: 0,
        totalXP: savedXP, // <-- use saved XP
        xpProgress: 0,
        level: 1,
        streak: 0,
        fallSpeed: 2.0,
        baseSpawn: 500,
        lastSpawn: 0,
        paused: false,
        started: false,
        highScore: savedHighScore,
        missPenalty: false
      };
      let gameLoopId, lastTime = 0;
      const colors = [
  '#f44336', // Red
  '#ffeb3b', // Yellow
  '#4caf50', // Green
  '#2196f3',  // Blue
  '#6A3094', // Purple
];
const dropGradients = [
  { top: '#ff7961', main: '#f44336', shadow: '#b71c1c' }, // Red
  { top: '#fffde7', main: '#ffeb3b', shadow: '#fbc02d' }, // Yellow
  { top: '#b9f6ca', main: '#4caf50', shadow: '#1b5e20' }, // Green
  { top: '#82b1ff', main: '#2196f3', shadow: '#0d47a1' }, // Blue
  { top: '#8763AA', main: '#6A3094', shadow: '#7B5E99' }, // Purple
];
      let targetColor = colors[0];

      // --- Slow-mo palette drop state ---
      let slowMoTimeout = null;
      let slowMoActive = false;

      // Add this near the top with other state variables:
      let speedBurstTimeout = null;

      // --- Controls Instructions ---
      function isMobile() {
        return /Android|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(navigator.userAgent);
      }
      const desktopControls = `
        <h2>How to Play</h2>
        <ul>
          <li><b>Move:</b> <span class="kbd">‚Üê</span> <span class="kbd">‚Üí</span></li>
          <li><b>Pause:</b> <span class="kbd">Space</span></li>
                  </ul>
        <div class="tip">Catch the <span style="font-weight:bold;">target color</span> to score, catch the wrong color and lose a life!</div>
            <h2>Power-Ups & Hazards</h2>
  <ul>
    <li>üé® <b>Paint Palette:</b> Slow Motion</li>
    <li>üíß <b>Water Drop:</b> Speed Burst</li>
    <li>‚ö´Ô∏è <b>Ink Blot:</b> Lose 2 Lives</li>
      `;
      const mobileControls = `
        <h2>How to Play</h2>
        <ul>
          <li><b>Move:</b> Drag left/right</li>
          <li><b>Pause:</b> Two-finger tap</li>
          <div class="tip">Catch the <span style="font-weight:bold;">target color</span> to score, catch the wrong color and lose a life!</div>
            </ul>
  <h2>Power-Ups & Hazards</h2>
  <ul>
    <li>üé® <b>Paint Palette:</b> Slow Motion</li>
    <li>üíß <b>Water Drop:</b> Speed Burst</li>
    <li>‚ö´Ô∏è <b>Ink Blot:</b> Lose 2 Lives</li>
        </ul>
        
        
      `;

      function updateHomeScreenContent() {
        mainControlsInstructions.innerHTML = isMobile() ? mobileControls : desktopControls;
        pauseHint.textContent = isMobile() ? 'Two-finger tap to pause' : 'Space bar to pause';
        mainActionBtn.textContent = state.paused ? 'Resume Game' : 'Start Game';
      }

      // --- Show/hide home screen ---
      function showHomeScreen(show, isPause = false) {
        state.paused = isPause;
        homeScreen.classList.toggle('hidden', !show);
        updateHomeScreenContent();
        mainSettingsPanel.classList.add('hidden');
      }

      // --- Minimal feedback ---
      let feedbackTimeout;
      function showFeedback(msg) {
        feedback.textContent = msg;
        feedback.classList.remove('hidden');
        feedback.style.opacity = 1;
        feedback.style.transform = "translateX(-50%) scale(0.8)";
        clearTimeout(feedbackTimeout);
        setTimeout(() => {
          feedback.style.transition = 'opacity 0.4s';
          feedback.style.opacity = 0;
          setTimeout(() => {
            feedback.classList.add('hidden');
            feedback.style.transition = '';
          }, 1000);
        }, 1000); // linger for 1 second
      }

      // --- Game logic ---
      const catcher = {
        x: canvas.width/2 - 30 * SCALE,
        y: canvas.height - 120 * SCALE,
        w: 10 * SCALE,
        h: 170 * SCALE,
        velX: 0,
        speed: 8
      };
      const circles = [];
      const particles = [];
      const keys = { left: false, right: false };
      function updateVel() { catcher.velX = (keys.right ? 1 : 0) - (keys.left ? 1 : 0); }
      function hexToRgb(h) {
        const c = h.slice(1);
        return `${parseInt(c.substr(0,2),16)},${parseInt(c.substr(2,2),16)},${parseInt(c.substr(4,2),16)}`;
      }
      function drawRounded(x,y,w,h,r) {
        ctx.beginPath();
        ctx.moveTo(x+r,y);
        ctx.lineTo(x+w-r,y);
        ctx.quadraticCurveTo(x+w,y,x+w,y+r);
        ctx.lineTo(x+w,y+h-r);
        ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
        ctx.lineTo(x+r,y+h);
        ctx.quadraticCurveTo(x,y+h,x,y+h-r);
        ctx.lineTo(x,y+r);
        ctx.quadraticCurveTo(x,y,x+r,y);
        ctx.fill();
      }
      function createParticles(x,y,color) {
        for (let i=0; i<20; i++) {
          particles.push({
            x, y,
            dx: (Math.random()-0.5)*4,
            dy: (Math.random()-0.5)*4,
            r: 3+Math.random()*3,
            alpha: 1,
            color
          });
        }
      }
      function updateParticles() {
        for (let i=particles.length-1; i>=0; i--) {
          let p = particles[i];
          p.x += p.dx;
          p.y += p.dy;
          p.alpha -= 0.02;
          if (p.alpha <= 0) particles.splice(i,1);
        }
      }
      function drawParticles() {
        particles.forEach(p => {
          ctx.fillStyle = `rgba(${hexToRgb(p.color)},${p.alpha})`;
          ctx.beginPath();
          ctx.arc(p.x,p.y,p.r,0,2*Math.PI);
          ctx.fill();
        });
      }

      // --- Power-Ups & Obstacles ---
      function spawnCircle() {
        let roll = Math.random();
        let type = 'normal';
        if (roll < 0.06) type = 'palette'; // 6% chance: paint palette
        else if (roll < 0.12) type = 'water'; // 6% chance: blue water drop
        else if (roll < 0.18) type = 'bomb'; // 6% chance: black inkblot
        let baseSpd = 2 + state.score*0.05;
        circles.push({
          x: Math.random()*(canvas.width-45*SCALE)+22.5*SCALE,
          y: -30 * SCALE,
          r: (15 + Math.random()*10) * SCALE,
          baseSpd,
          spd: baseSpd * state.fallSpeed,
          color: type === 'palette'
      ? targetColor                       // ‚Üê now uses the current targetColor
      : type === 'water' ? '#80d8ff'
      : type === 'bomb'   ? '#222'
      : colors[Math.floor(Math.random()*colors.length)],
          type
        });
      }

      // --- Combo & Streak System ---
      let comboTimer = null;
      let comboCount = 0;
      function resetCombo() {
        comboCount = 0;
        if (comboTimer) clearTimeout(comboTimer);
        comboTimer = null;
      }
      function addCombo() {
        comboCount++;
        if (comboTimer) clearTimeout(comboTimer);
        comboTimer = setTimeout(resetCombo, 2000); // 2s to keep combo
        if (comboCount > 1) showFeedback(`Combo x${comboCount}!`);
      }

      function drawBackground() {
        let t = Math.min(1, state.score/1000);
        let c1 = `hsl(${200-100*t},80%,70%)`;
        let c2 = `hsl(${50+50*t},90%,90%)`;
        let grad = ctx.createLinearGradient(0,0,0,canvas.height);
        grad.addColorStop(0,c1);
        grad.addColorStop(1,c2);
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,canvas.width,canvas.height);
      }
      function drawCatcher() {
  // 1) Position & flip so ‚Äúup‚Äù is brush tip
  ctx.save();
  ctx.translate(catcher.x + catcher.w/2, catcher.y + catcher.h/2);
  ctx.rotate(Math.PI);

  // 2) Draw wooden handle base with gradient
  ctx.beginPath();
  ctx.roundRect(-8 * SCALE, -35 * SCALE, 16 * SCALE, 45 * SCALE, 5 * SCALE);
  let handleGrad = ctx.createLinearGradient(-8 * SCALE, -35 * SCALE, 8 * SCALE, 10 * SCALE);
  handleGrad.addColorStop(0, '#8d6e63');
  handleGrad.addColorStop(1, '#5d4037');
  ctx.fillStyle = handleGrad;
  ctx.fill();

  // 3) Clip to that handle area, then draw grain & speckles
  ctx.save();
  ctx.beginPath();
  ctx.roundRect(-8 * SCALE, -35 * SCALE, 16 * SCALE, 45 * SCALE, 5 * SCALE);
  ctx.clip();

  //   a) Wavy grain lines
  ctx.strokeStyle = 'rgba(0,0,0,0.15)';
ctx.lineWidth = 1;
for (let xx = -6; xx <= 6; xx += 4) {
  ctx.beginPath();
  let phase = Math.random() * Math.PI * 2;
  ctx.moveTo(xx * SCALE, -35 * SCALE);
  // step down the handle height
  for (let yy = -35; yy <= 10; yy += 2) {
    // sinuous x-offset based on vertical position
    let xOff = Math.sin(((yy + 35) / 45) * Math.PI + phase) * .5;
    ctx.lineTo((xx + xOff) * SCALE, yy * SCALE);
  }
  ctx.stroke();
}

  //   b) Tiny random speckles
  for (let i = 0; i < 25; i++) {
    let rx = (-8 + Math.random() * 16) * SCALE;
    let ry = (-35 + Math.random() * 45) * SCALE;
    let sz = Math.random() * 1.5 * SCALE;
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.fillRect(rx, ry, sz, sz);
  }
  ctx.restore(); // end clip

  // 4) Draw metal ferrule
  ctx.beginPath();
  ctx.roundRect(-10 * SCALE, 10 * SCALE, 20 * SCALE, 15 * SCALE, 2 * SCALE);
  let metalGrad = ctx.createLinearGradient(-10 * SCALE, 10 * SCALE, 10 * SCALE, 25 * SCALE);
  metalGrad.addColorStop(.5, '#e0e0e0');
  metalGrad.addColorStop(1, '#9e9e9e');
  ctx.fillStyle = metalGrad;
  ctx.fill();

  // 5) Draw the paint‚Äêcolored bristles
  ctx.beginPath();
  ctx.moveTo(-10 * SCALE, 25 * SCALE);
  ctx.quadraticCurveTo(0, 45 * SCALE, 10 * SCALE, 25 * SCALE);
  ctx.fillStyle = targetColor;
  ctx.fill();

  ctx.restore(); // back to canvas default
}

      function drawCircles() {
        circles.forEach(circle => {
          if (circle.type === 'bomb') {
            drawInkBlot(circle.x, circle.y, circle.r);
          } else if (circle.type === 'water') {
            drawWaterDrop(circle.x, circle.y, circle.r);
          } else if (circle.type === 'palette') {
            drawPaletteDrop(circle.x, circle.y, circle.r);
          } else {
            drawPaintDrop(circle.x, circle.y, circle.r, circle.color);
          }
        });
      }
      function updateXP() {
  state.totalXP += 10;
  state.xpProgress += 10;

  xpEl.textContent = Math.floor(state.totalXP);
  levelEl.textContent = state.level;

  let threshold = state.level * 10;
  while (state.xpProgress >= threshold) {
    state.xpProgress -= threshold;
    state.level++;
    levelEl.textContent = state.level;
    threshold = state.level * 100;
    state.fallSpeed *= 1.05;
    state.baseFallSpeed = state.fallSpeed;
  }
  // Save XP persistently
  localStorage.setItem('totalXP', state.totalXP);
      }

      // --- Update function with power-up logic ---
      function update(dt) {
        // Gradually increase drop spawn rate: by level 10, 20% more drops (spawn interval 20% shorter)
        let spawnMultiplier = 1 - 0.2 * Math.min(1, (state.level-1)/9);
        let spawnInterval = state.baseSpawn * spawnMultiplier;
        if (Date.now() - state.lastSpawn > spawnInterval / state.fallSpeed) {
          spawnCircle();
          state.lastSpawn = Date.now();
        }
        catcher.x = Math.max(0, Math.min(canvas.width-catcher.w, catcher.x + catcher.velX * catcher.speed * (dt/16)));
        for (let i=circles.length-1; i>=0; i--) {
  let c = circles[i];
  c.spd = c.baseSpd * state.fallSpeed;
  c.y += c.spd;

  // Tip of bristles area (at the top of the brush, before rotation)
  const tipLeft   = catcher.x + (catcher.w/2 - 10*SCALE);
  const tipRight  = catcher.x + (catcher.w/2 + 10*SCALE);
  const tipTop    = catcher.y + 25*SCALE + 40*SCALE;
  const tipBottom = tipTop + 10*SCALE;

  // Only catch if the drop overlaps the tip area
  let caught =
    c.x + c.r > tipLeft &&
    c.x - c.r < tipRight &&
    c.y + c.r > tipTop &&
    c.y - c.r < tipBottom;

  let missed = c.y-c.r > canvas.height;
          if (caught || missed) {
            if (caught) {
              createParticles(c.x,c.y,c.color);
              // --- Power-up logic ---
              if (c.type === 'palette') {
  // only trigger once per drop
  if (!slowMoActive) {
    slowMoActive = true;
    // slow the fall speed
    state._originalFallSpeed = state.fallSpeed;
    state.fallSpeed          = Math.max(0.7, state.fallSpeed * 0.7);
    // double XP for 2 seconds
    state.xpMultiplier       = 2;
    showFeedback('Slow Motion!');
    if (slowMoTimeout) clearTimeout(slowMoTimeout);
    slowMoTimeout = setTimeout(() => {
      state.fallSpeed     = state._originalFallSpeed;
      state.xpMultiplier  = 1;    // back to normal XP
      slowMoActive        = false;
    }, 2000);
  }
              } else if (c.type === 'water') {
  state.score += 1;

  // speed-burst logic (1 second, always resets)
  if (speedBurstTimeout) clearTimeout(speedBurstTimeout);
  // Save the "base" fall speed (from level progression)
  if (typeof state.baseFallSpeed === "undefined") state.baseFallSpeed = state.fallSpeed;
  state.fallSpeed = state.baseFallSpeed * 1.5; // 50% faster

  showFeedback('Speed Burst!');
  speedBurstTimeout = setTimeout(() => {
    state.fallSpeed = state.baseFallSpeed;
    speedBurstTimeout = null;
  }, 1000);

  addCombo();
              } else if (c.type === 'bomb') {
                state.lives = Math.max(0, state.lives - 2);
                showFeedback('Bomb! -2 Lives');
                resetCombo();
              } else {
                if (c.color === targetColor) {
                  state.score++;
                  state.streak++;
                  addCombo();
                  updateXP(10);
                  targetColor = colors[Math.floor(Math.random()*colors.length)];
                  if (state.score > state.highScore) {
                    state.highScore = state.score;
                    localStorage.setItem('highScore',state.highScore);
                    highScoreEl.textContent = state.highScore;
                  }
                } else {
                  state.lives--;
                  state.streak = 0;
                  resetCombo();
                }
                if (state.streak>0 && state.streak%10===0) {
                  state.lives = Math.min(state.maxLives,state.lives+1);
                }
              }
            }
            scoreEl.textContent = state.score;
            livesEl.textContent = state.lives;
            targetColorBox.style.backgroundColor = targetColor;
            circles.splice(i,1);
          }
        }
        updateParticles();
      }

      function gameLoop(ts) {
        if (state.paused) return;
        let dt = ts - lastTime;
        lastTime = ts;
        drawBackground();
        drawCatcher();
        drawCircles();
        drawParticles();
        update(dt);
        if (state.lives <= 0) {
          cancelAnimationFrame(gameLoopId);
          finalScoreEl.textContent = state.score;
          finalHighScoreEl.textContent = state.highScore;
          gameOver.classList.remove('hidden');
          hud.classList.add('hidden');
          return;
        }
        gameLoopId = requestAnimationFrame(gameLoop);
      }
      function startGame() {
        state.score = 0;
        state.lives = 3;
        state.xp = 0;
        state.level = 1;
        state.streak = 0;
        state.lastSpawn = 0;
        state.fallSpeed = 1.0; // Start fast!
        scoreEl.textContent = '0';
        xpEl.textContent = '0';
        levelEl.textContent = '1';
        livesEl.textContent = '3';
        highScoreEl.textContent = state.highScore;
        targetColor = colors[Math.floor(Math.random()*colors.length)];
        targetColorBox.style.backgroundColor = targetColor;
        homeScreen.classList.add('hidden');
        hud.classList.remove('hidden');
        gameOver.classList.add('hidden');
        circles.length = 0;
        particles.length = 0;
        lastTime = performance.now();
        state.started = true;
        state.paused = false;
  // DO NOT reset state.xp, state.xpProgress, or state.level here!
  xpEl.textContent = Math.floor(state.totalXP);
  levelEl.textContent = state.level;
  gameLoopId = requestAnimationFrame(gameLoop);
        gameLoopId = requestAnimationFrame(gameLoop);
      }
      function resumeGame() {
        state.paused = false;
        state.baseFallSpeed = state.fallSpeed;
        showHomeScreen(false);
        hud.classList.remove('hidden');
        lastTime = performance.now();
        gameLoopId = requestAnimationFrame(gameLoop);
      }
      mainActionBtn.onclick = () => {
        if (!state.started) startGame();
        else resumeGame();
      };
      mainSettingsBtn.onclick = () => {
        mainSettingsPanel.classList.toggle('hidden');
      };
      mainMissPenalty.oninput = () => {
        state.missPenalty = mainMissPenalty.checked;
      };
      // Keyboard controls
      document.addEventListener('keydown', e => {
        if (e.key === ' ') {
          if (!state.paused && state.started) {
            state.paused = true;
            showHomeScreen(true, true);
            hud.classList.add('hidden');
          } else if (state.paused) {
            resumeGame();
          }
        }
        if (e.key === 'ArrowLeft') { keys.left = true; updateVel(); }
        if (e.key === 'ArrowRight') { keys.right = true; updateVel(); }
      });
      document.addEventListener('keyup', e => {
        if (e.key === 'ArrowLeft') { keys.left = false; updateVel(); }
        if (e.key === 'ArrowRight') { keys.right = false; updateVel(); }
      });
      // Touch controls
      let touchOffset = 0;
      let swipeStartY = null;
      canvas.addEventListener('touchstart', e => {
        if (e.touches.length === 2) {
          if (!state.paused && state.started) {
            state.paused = true;
            showHomeScreen(true, true);
            hud.classList.add('hidden');
          } else if (state.paused) {
            resumeGame();
          }
        } else {
          const rect = canvas.getBoundingClientRect();
          let x = e.touches[0].clientX - rect.left;
          touchOffset = x - catcher.x;
          swipeStartY = e.touches[0].clientY;
        }
      });
      canvas.addEventListener('touchmove', e => {
        const rect = canvas.getBoundingClientRect();
        let x = e.touches[0].clientX - rect.left;
        catcher.x = Math.max(0, Math.min(canvas.width - catcher.w, x - touchOffset));
        if (swipeStartY !== null) {
          let currentY = e.touches[0].clientY;
          let deltaY = currentY - swipeStartY;
          if (Math.abs(deltaY) > 30) {
            swipeStartY = currentY;
          }
        }
      });
      canvas.addEventListener('touchend', e => {
        swipeStartY = null;
      });
      // Restart
      restartBtn.onclick = () => {
        state.started = false;
        circles.length = 0;
        particles.length = 0;
        showHomeScreen(true, false);
      };
      // Initial state
      highScoreEl.textContent = state.highScore;
      showHomeScreen(true, false);

      // --- Drawing Functions ---
      function drawPaintDrop(x, y, r, color) {
  ctx.save();
  ctx.translate(x, y);

  // Find the gradient for this color
  let idx = colors.indexOf(color);
  let gradDef = dropGradients[idx >= 0 ? idx : 0];

  // Drop shape: pointy top, bulbous bottom, little tail
  ctx.beginPath();
  ctx.moveTo(0, -r * 1.35);
  ctx.bezierCurveTo(
    r * 0.12, -r * 1.0,
    r * 0.95, r * 0.6,
    0, r * .7
  );
  ctx.bezierCurveTo(
    -r * 0.95, r * 0.6,
    -r * 0.12, -r * 1.0,
    0, -r * 1.5
  );

  // Gradient fill
  let gradient = ctx.createLinearGradient(0, -r * 1.35, 0, r * 1.22);
  gradient.addColorStop(0.0, gradDef.top);
  gradient.addColorStop(0.25, gradDef.main);
  gradient.addColorStop(1.0, gradDef.shadow);
  ctx.fillStyle = gradient;
  ctx.fill();

  ctx.restore();
}

      function drawInkBlot(x, y, r) {
        ctx.save();
        ctx.translate(x, y);

        // Central blob
        ctx.beginPath();
        ctx.arc(0, 0, r * 0.7, 0, Math.PI * 2);

        // Blot arms
        let arms = 8 + Math.floor(Math.random() * 4);
        for (let i = 0; i < arms; i++) {
          let angle = (i / arms) * Math.PI * 2 + Math.random() * 0.2;
          let armLen = r * (0.2 + Math.random() * 0.7);
          let armWidth = r * (0.09 + Math.random() * 0.12);

          let ax = Math.cos(angle) * armLen;
          let ay = Math.sin(angle) * armLen;

          ctx.moveTo(0, 0);
          ctx.quadraticCurveTo(
            Math.cos(angle) * (armLen * 0.5 + Math.random() * r * 0.2),
            Math.sin(angle) * (armLen * 0.5 + Math.random() * r * 0.2),
            ax, ay
          );
          ctx.arc(ax, ay, armWidth, 0, Math.PI * 2);
        }

        ctx.closePath();
        ctx.fillStyle = "#181818";
        ctx.shadowColor = "rgba(0,0,0,0.35)";
        ctx.shadowBlur = 18;
        ctx.fill();
        ctx.restore();
      }

      function drawWaterDrop(x, y, r) {
        ctx.save();
        ctx.translate(x, y);
        ctx.beginPath();
        ctx.moveTo(0, -r * 1.35);
        ctx.bezierCurveTo(
    r * 0.12, -r * 1.0,
    r * 0.95, r * 0.6,
    0, r * .7
  );
  ctx.bezierCurveTo(
    -r * 0.95, r * 0.6,
    -r * 0.12, -r * 1.0,
    0, -r * 1.5
  );
        let gradient = ctx.createRadialGradient(0, r * 0.7, r * 0.1, 0, 0, r);
        gradient.addColorStop(0, '#c4ecf2');
        gradient.addColorStop(0.25, '#80d8ff');
        gradient.addColorStop(1, '#0288d1');
        ctx.fillStyle = gradient;
        ctx.shadowColor = "rgba(0,180,255,0.13)";
        ctx.shadowBlur = 8;
        ctx.fill();
        // Water highlight
        ctx.beginPath();
        ctx.ellipse(-r * 0.13, -r * 0.8, r * 0.13, r * 0.07, Math.PI / 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.38)';
        ctx.fill();
        ctx.restore();
      }
      function drawPaletteDrop(x, y, r) {
        ctx.save();
        ctx.font = `${r*2}px serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.globalAlpha = 0.96;
        ctx.fillText("üé®", x, y+2);
        ctx.globalAlpha = .75;
        ctx.restore();
      }
      function adjustColor(color, amount) {
        // Only works for hex colors like #rrggbb
        if (!/^#[0-9a-f]{6}$/i.test(color)) return color;
        let r = Math.max(0, Math.min(255, parseInt(color.substr(1,2),16) + amount));
        let g = Math.max(0, Math.min(255, parseInt(color.substr(3,2),16) + amount));
        let b = Math.max(0, Math.min(255, parseInt(color.substr(5,2),16) + amount));
        return `rgb(${r},${g},${b})`;
      }

      // --- Touch controls (trackpad) ---
      trackpad.addEventListener('touchstart', e => {
        if (e.touches.length === 1) {
          const rect = trackpad.getBoundingClientRect();
          let x = e.touches[0].clientX - rect.left;
          touchOffset = x - catcher.x;
        }
      });
      trackpad.addEventListener('touchmove', e => {
        e.preventDefault();
        const rect = trackpad.getBoundingClientRect();
        let x = e.touches[0].clientX - rect.left;
        catcher.x = Math.max(0, Math.min(canvas.width - catcher.w, x - touchOffset));
      }, { passive: false });
    });
  </script>
  <style>
    #feedback {
      position:fixed;
      left:50%;
      top:80px;
      transform:translateX(-50%) scale(0.8);
      background:rgba(34,34,34,0.6);
      color:#fff;
      font-size:1rem;
      padding:6px 16px;
      border-radius:12px;
      box-shadow:0 2px 8px #0002;
      z-index:20;
      pointer-events:none;
      opacity:0;
      transition:opacity 0.4s, transform 0.2s;
    }
    #feedback:not(.hidden) { opacity:1; }
    #mainSettingsPanel button[type="button"] {
      font-size: 0.9em;
      padding: 2px 10px;
      border-radius: 8px;
      background: #eee;
      color: #333;
      border: 1px solid #bbb;
      margin-left: 8px;
      cursor: pointer;
      box-shadow: none;
      transition: background 0.2s;
    }
    #mainSettingsPanel button[type="button"]:hover {
      background: #ddd;
    }
    #trackpad {
      display: none;
      width: 90vw;
      max-width: 600px;
      height: 45px;
      margin: 0 auto 0 auto;
      background: #e3e9f1;
      border-radius: 0 0 16px 16px;
      box-shadow: 0 2px 8px #0001;
      position: relative;
      touch-action: pan-x pan-y;
      z-index: 2;
      user-select: none;
      text-align: center;
      font-size: 1.1em;
      color: #888;
      letter-spacing: 0.02em;
      line-height: 90px;
    }
    @media (pointer: coarse) {
      #trackpad { display: block; }
      
    }
  </style>
</body>
</html>
